import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as r,c as s,d,a as e,b as n,e as i,f as l}from"./app-c703f97d.js";const c={},h=e("h2",{id:"aes",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#aes","aria-hidden":"true"},"#"),n(" AES")],-1),p=e("p",null,"Advanced Encryption Standard，又称Rijndael加密法，是一种对称加密算法。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。",-1),_=e("p",null,"AES算法密钥长度可以是128比特、192比特、256比特。",-1),u=e("h3",{id:"算法原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#算法原理","aria-hidden":"true"},"#"),n(" 算法原理")],-1),m=e("p",null,"只讲原理，也只能讲原理。。。目前的数学水平已经不能再深入这个算法原理了。",-1),S=e("p",null,"对称加密，简单来说就是加密、解密使用同一个密钥，经过一个可逆的算法对数据加、解密。",-1),f=e("blockquote",null,[e("p",null,"什么算法呢？一会说。")],-1),E=l(`<p>AES是基于分组加密的，分组加密是：</p><ul><li>选取固定长度的密钥，以密钥长度为单位对明文数据进行分组；(不够做数据补齐)</li><li>使用密钥对每个分组的数据进行加密；加密算法以密钥、明文分组为输入，以密文组为输出；</li><li>生成的密文与明文块长度一样；所有密文组并在一起，就是最终输出的密文。</li></ul><p>以AES 128位密钥为例：以128 bit为一组进行加密，就是每次加密16个字节，因此每次输入16个字节的明文输出16个字节密文；如果明文是32个字节，那么分成两组依次进行加密。</p><h4 id="什么加密算法呢" tabindex="-1"><a class="header-anchor" href="#什么加密算法呢" aria-hidden="true">#</a> 什么加密算法呢？</h4><p>AES算法是基于置换和代替的。置换是数据的重新排列，而代替是用一个单元数据替换另一个。原理就这么简单，但如何保证算法可逆又可靠呢？这个我分析不能。。。</p><p><strong>据置换和代替方式的不同，有几种加密模式：</strong></p><ul><li><p>ECB 不是特别可靠，例如：如果输入明文<code>12345678123456781234567812345678</code>，算法生成unsigned char型密文打印结果为：</p><pre><code>  231  112  41  149  134  190  231  4  248  190  183  7  198  137  19  77  
  231  112  41  149  134  190  231  4  248  190  183  7  198  137  19  77
</code></pre></li></ul><p>这已经能看出密文规律了，于是有了其它模式来解决这个问题。</p><ul><li>CBC 要求给一个初始化的向量，然后将每个输出与该向量作运算，并将运算的结果作为下一个加密块的初始化向量</li><li>CFB 和 OFB 则不需要提供初始化向量，直接将密码或者输出作为初始化向量进行运算</li></ul><h3 id="数据补齐" tabindex="-1"><a class="header-anchor" href="#数据补齐" aria-hidden="true">#</a> 数据补齐</h3><p>因为明文长度不固定，会出现不能完全分组的情况，这时候就要把数据补齐到密钥长度的整数倍。数据补齐有一些方式：PKCS5,PKCS7等等，有些实现默认补齐\\0。</p><h3 id="算法实现" tabindex="-1"><a class="header-anchor" href="#算法实现" aria-hidden="true">#</a> 算法实现</h3>`,12),x={href:"http://www.openssl.org/",target:"_blank",rel:"noopener noreferrer"};function C(b,A){const a=t("ExternalLinkIcon");return r(),s("div",null,[h,p,_,u,m,S,f,d(" more "),E,e("p",null,[n("网上搜了搜C/C++实现，貌似OpenSSL中的实现不错，可以使用整个OpenSSL库，或者从中抽取AES部分单独使用。 "),e("a",x,[n("OpenSSL官网"),i(a)])])])}const g=o(c,[["render",C],["__file","2013-04-03-common-encrpt-aes.html.vue"]]);export{g as default};
