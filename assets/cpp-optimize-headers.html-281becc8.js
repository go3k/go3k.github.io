import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as r,c as o,a as e,b as n,e as l,f as a}from"./app-c703f97d.js";const c={},s=a(`<p>当一个C++项目越来越庞大，编译时间会慢的让人难受。虽说编译执行的语言在编译阶段都存在类似的问题，但是很多时候错误的编码习惯才是这类问题的根源。</p><h2 id="头文件包含问题" tabindex="-1"><a class="header-anchor" href="#头文件包含问题" aria-hidden="true">#</a> 头文件包含问题</h2><p>如果你的项目随便修改了某个头文件，就造成整个项目大规模的重新编译，那么就需要注意头文件包含问题了。</p><p>问题原因是，C/C++中<code>#include</code>是一个预编译关键字，预编译处理时它会将<code>#include</code>后面的文件内容直接复制过来。当include后面的文件有修改，那么当前文件也会被认为有修改，该文件会被重新编译。举例说明：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>	//A.h
	void A_dosth();
	//B.h
	#include &quot;A.h&quot;
	void B_dosth();
	//B.cpp
	#include &quot;B.h&quot;
	void B_dosth()
	{
		//......
	}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果<code>A.h</code>或<code>B.h</code>任一文件有修改，那么<code>B.cpp</code>就会被重新编译。</p><p>可以想象一下更加复杂的情况，头文件之间互相嵌套包含，当嵌套关系上的任何一个头文件修改时，所有包含它的文件都会重新编译。如果不加以控制，整个项目就像蝴蝶效应一般，牵一发动全身。每个修改都将带来大量文件的编译，开发效率极受影响。</p><h2 id="建议编码原则" tabindex="-1"><a class="header-anchor" href="#建议编码原则" aria-hidden="true">#</a> 建议编码原则</h2>`,8),h={href:"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Forward_Declarations#Forward_Declarations",target:"_blank",rel:"noopener noreferrer"},u={href:"http://blog.csdn.net/wo17fang/article/details/25280577",target:"_blank",rel:"noopener noreferrer"},p=e("li",null,[n("Unity Build，把关联的cpp包含到一个"),e("code",null,"all.cpp"),n("中 ,然后只编译"),e("code",null,"all.cpp"),n("。")],-1),_=e("li",null,"面向接口编程，定义好模块的接口。代码尽量接近MVC模式，只在Controller部分做各模块间的通信。",-1),m=e("li",null,"不要滥用单例模式，例如：Datamanager单例用于获取数据，开发过程中数据结构和接口会经常变化和新增的；如果到处使用datamanager单例获取数据，那么每次对datamanager的修改会造成代码大规范编译。",-1),v=a('<h2 id="自动化工具" tabindex="-1"><a class="header-anchor" href="#自动化工具" aria-hidden="true">#</a> 自动化工具</h2><p>代码重构后，忘记删除某些头文件包含。积累下来，项目中有很多unused include。人工检查这类问题会费时费力，下面推荐一些工具化的手段。</p><h3 id="visual-studio-12自带功能" tabindex="-1"><a class="header-anchor" href="#visual-studio-12自带功能" aria-hidden="true">#</a> Visual Studio 12自带功能</h3><ul><li>vs中的showinclude选项，编译时可以显示每个cpp中使用的所有头文件，是一个层级结构，这可以帮助分析。如果某个文件重复出现，则认定为重复包含。</li><li>Generate Graph of Include Files，这个功能非常强大，可以生成某个文件的头文件包含情况图，可以用来非常直观的分析头文件的包含结构。其实这个功能，可以反应程序结构设计好坏，协助及时发现设计问题。</li></ul><h3 id="c-c-静态分析工具pc-lint" tabindex="-1"><a class="header-anchor" href="#c-c-静态分析工具pc-lint" aria-hidden="true">#</a> C/C++静态分析工具PC-lint</h3><p>资历最老，牌子最响，功能非常强大应有尽有。</p><ul><li>支持大部分的编译器</li><li>支持大部分的IDE</li><li>可检查代码中隐含的错误，检查非常严格；提示unused include情况，提供类前置声明建议；等等</li><li>跨平台，类Unix版本名为Flexe-Lint</li></ul>',7),b={href:"http://www.gimpel.com/html/pcl.htm",target:"_blank",rel:"noopener noreferrer"},f=e("h2",{id:"参考链接",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考链接","aria-hidden":"true"},"#"),n(" 参考链接")],-1),g={href:"http://www.cnblogs.com/baiyanhuang/archive/2010/01/17/1730717.html",target:"_blank",rel:"noopener noreferrer"};function x(w,B){const i=d("ExternalLinkIcon");return r(),o("div",null,[s,e("ul",null,[e("li",null,[n("头文件中尽量使用类前置声明，避免在头文件中包含其它头文件。"),e("a",h,[n("Google c++ Style Guide"),l(i)])]),e("li",null,[n("使用PIMPL，降低不同模块之间的编译依赖。具体参考："),e("a",u,[n("csdn文章"),l(i)])]),p,_,m]),v,e("p",null,[e("a",b,[n("PC-lint官方网站"),l(i)])]),f,e("p",null,[e("a",g,[n("如何加快C++代码的编译速度"),l(i)])])])}const V=t(c,[["render",x],["__file","cpp-optimize-headers.html.vue"]]);export{V as default};
