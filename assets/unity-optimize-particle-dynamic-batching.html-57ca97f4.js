import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as a,f as i}from"./app-c703f97d.js";const r={},c=i('<p>Unity 5.3.5 版本以后恢复了对粒子系统的动态合批功能，需要注意的是，粒子系统合批的前提是渲染顺序上相邻，且材质相同。默认情况下，粒子系统的渲染与一般的半透明渲染一样，必须从后向前渲染。</p><h2 id="order-in-layer" tabindex="-1"><a class="header-anchor" href="#order-in-layer" aria-hidden="true">#</a> order in layer</h2><p><img src="http://7jppsr.com1.z0.glb.clouddn.com/img/unity_particle_orderinlayer.png" alt="orderinlayer" loading="lazy"><code>ParticleSystem</code>这个Component下的<code>Render</code>标签下面，这个参数可以设定该粒子的渲染顺序。</p><p>例子：一个表现两军交战的场景，双方战斗单位20v20，每次攻击每个战斗单位射出一个粒子效果表示飞行子弹。该粒子效果包含两个<code>ParticleSystem</code>，各自引用了不同的<code>Material</code>。由于渲染顺序问题，很有可能这些粒子效果是不能合批的，因为两个<code>ParticleSystem</code>交替渲染会造成<code>Material</code>相同这个条件不成立，导致<code>drawcall</code>数量是<code>特效数量 * 2</code>。</p><p>优化：把两个粒子的<code>order in layer</code>分别修改为0、1，粒子系统的dynamic batching就会生效，最终<code>drawcall</code>数量变成2。</p><h2 id="广度上的优化" tabindex="-1"><a class="header-anchor" href="#广度上的优化" aria-hidden="true">#</a> 广度上的优化</h2><p>因为动态合批的前提条件之一是&quot;材质相同&quot;，如果我们尽可能保证粒子系统的&quot;材质相同&quot;就能有更多的动态合批，这可行吗？</p><h3 id="材质之间的主要区别" tabindex="-1"><a class="header-anchor" href="#材质之间的主要区别" aria-hidden="true">#</a> 材质之间的主要区别</h3><ol><li>使用的贴图不同</li><li>使用的shader不同</li></ol><p>经过一些研究，发现大部分特效的贴图比较小，或者说移动游戏特效贴图可以限定到很小；最常用的particle shader只用2到3个。</p><h3 id="优化方案" tabindex="-1"><a class="header-anchor" href="#优化方案" aria-hidden="true">#</a> 优化方案</h3><p>利用SpritePacker把特效texture合并为一个图集，根据使用的particle shader不同来对应图集，这样我们就得到了2到3个shader和贴图相同的“相同材质球”。具体步骤如下：</p><ol><li>修改Texture type为Sprite，Packing Tag中填入对应shader的名字，例如：BattleParticle_additive <img src="http://7jppsr.com1.z0.glb.clouddn.com/img/unity_particle_spritetexture.png" alt="textureFormat" loading="lazy"></li><li>创建名称为<code>BattleParticle_additive</code>的材质球，Shader选择<code>Additive</code>，texture留空。</li><li>在粒子特效的<code>ParticleSystem</code>下，在<code>Render</code>标签中选择Material为刚才创建的<code>BattleParticle_additive</code>。开启<code>Texture Sheet Animation</code>选项，Mode选择Sprites，把步骤1中的Sprite拖上去，Frame Over Time选择constant。</li></ol><figure><img src="http://7jppsr.com1.z0.glb.clouddn.com/unity_particle_settexturesheet.png" alt="textureSheet" tabindex="0" loading="lazy"><figcaption>textureSheet</figcaption></figure><p>经过测试发现同样的<code>Material</code>都会合批，并且关于sprite的处理非常方便，几乎无需关心，Unity出包时会自动通过SpritePacker编译图集，并且放入包体内。</p>',15),d=[c];function o(l,n){return t(),a("div",null,d)}const s=e(r,[["render",o],["__file","unity-optimize-particle-dynamic-batching.html.vue"]]);export{s as default};
