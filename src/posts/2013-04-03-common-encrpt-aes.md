---
comments: true
date: 2013-04-03
slug: common-encrpt-aes
title: 常用加密算法 - AES
category:
- 技术
tag:
- 数据结构与算法
---

## AES

Advanced Encryption Standard，又称Rijndael加密法，是一种对称加密算法。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。

AES算法密钥长度可以是128比特、192比特、256比特。

### 算法原理

只讲原理，也只能讲原理。。。目前的数学水平已经不能再深入这个算法原理了。

对称加密，简单来说就是加密、解密使用同一个密钥，经过一个可逆的算法对数据加、解密。
> 什么算法呢？一会说。
<!-- more -->

AES是基于分组加密的，分组加密是：
* 选取固定长度的密钥，以密钥长度为单位对明文数据进行分组；(不够做数据补齐)
* 使用密钥对每个分组的数据进行加密；加密算法以密钥、明文分组为输入，以密文组为输出；
* 生成的密文与明文块长度一样；所有密文组并在一起，就是最终输出的密文。

以AES 128位密钥为例：以128 bit为一组进行加密，就是每次加密16个字节，因此每次输入16个字节的明文输出16个字节密文；如果明文是32个字节，那么分成两组依次进行加密。

#### 什么加密算法呢？

AES算法是基于置换和代替的。置换是数据的重新排列，而代替是用一个单元数据替换另一个。原理就这么简单，但如何保证算法可逆又可靠呢？这个我分析不能。。。

**据置换和代替方式的不同，有几种加密模式：**

* ECB 不是特别可靠，例如：如果输入明文`12345678123456781234567812345678`，算法生成unsigned char型密文打印结果为：

		231  112  41  149  134  190  231  4  248  190  183  7  198  137  19  77  
		231  112  41  149  134  190  231  4  248  190  183  7  198  137  19  77

这已经能看出密文规律了，于是有了其它模式来解决这个问题。

* CBC 要求给一个初始化的向量，然后将每个输出与该向量作运算，并将运算的结果作为下一个加密块的初始化向量
* CFB 和 OFB 则不需要提供初始化向量，直接将密码或者输出作为初始化向量进行运算

### 数据补齐

因为明文长度不固定，会出现不能完全分组的情况，这时候就要把数据补齐到密钥长度的整数倍。数据补齐有一些方式：PKCS5,PKCS7等等，有些实现默认补齐\0。

### 算法实现

网上搜了搜C/C++实现，貌似OpenSSL中的实现不错，可以使用整个OpenSSL库，或者从中抽取AES部分单独使用。
[OpenSSL官网](http://www.openssl.org/)
